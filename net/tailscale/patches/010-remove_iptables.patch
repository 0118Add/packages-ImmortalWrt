--- a/cmd/derper/depaware.txt
+++ b/cmd/derper/depaware.txt
@@ -12,7 +12,6 @@ tailscale.com/cmd/derper dependencies: (
    W ðŸ’£ github.com/alexbrainman/sspi/negotiate                       from tailscale.com/net/tshttpproxy
         github.com/beorn7/perks/quantile                             from github.com/prometheus/client_golang/prometheus
      ðŸ’£ github.com/cespare/xxhash/v2                                 from github.com/prometheus/client_golang/prometheus
-   L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw
         github.com/fxamacker/cbor/v2                                 from tailscale.com/tka
         github.com/golang/groupcache/lru                             from tailscale.com/net/dnscache
         github.com/golang/protobuf/proto                             from github.com/matttproud/golang_protobuf_extensions/pbutil+
@@ -77,20 +76,6 @@ tailscale.com/cmd/derper dependencies: (
         google.golang.org/protobuf/runtime/protoimpl                 from github.com/golang/protobuf/proto+
         google.golang.org/protobuf/types/descriptorpb                from google.golang.org/protobuf/reflect/protodesc
         google.golang.org/protobuf/types/known/timestamppb           from github.com/prometheus/client_golang/prometheus+
-   L    gvisor.dev/gvisor/pkg/abi                                    from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/abi/linux                              from tailscale.com/util/linuxfw
-   L    gvisor.dev/gvisor/pkg/bits                                   from gvisor.dev/gvisor/pkg/abi/linux
-   L    gvisor.dev/gvisor/pkg/context                                from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/gohacks                                from gvisor.dev/gvisor/pkg/abi/linux+
-   L ðŸ’£ gvisor.dev/gvisor/pkg/hostarch                               from gvisor.dev/gvisor/pkg/abi/linux+
-   L    gvisor.dev/gvisor/pkg/linewriter                             from gvisor.dev/gvisor/pkg/log
-   L    gvisor.dev/gvisor/pkg/log                                    from gvisor.dev/gvisor/pkg/context
-   L    gvisor.dev/gvisor/pkg/marshal                                from gvisor.dev/gvisor/pkg/abi/linux+
-   L ðŸ’£ gvisor.dev/gvisor/pkg/marshal/primitive                      from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/state                                  from gvisor.dev/gvisor/pkg/abi/linux+
-   L    gvisor.dev/gvisor/pkg/state/wire                             from gvisor.dev/gvisor/pkg/state
-   L ðŸ’£ gvisor.dev/gvisor/pkg/sync                                   from gvisor.dev/gvisor/pkg/linewriter+
-   L    gvisor.dev/gvisor/pkg/waiter                                 from gvisor.dev/gvisor/pkg/context
         nhooyr.io/websocket                                          from tailscale.com/cmd/derper+
         nhooyr.io/websocket/internal/errd                            from nhooyr.io/websocket
         nhooyr.io/websocket/internal/xsync                           from nhooyr.io/websocket
@@ -156,9 +141,9 @@ tailscale.com/cmd/derper dependencies: (
         tailscale.com/util/dnsname                                   from tailscale.com/hostinfo+
         tailscale.com/util/httpm                                     from tailscale.com/client/tailscale
         tailscale.com/util/lineread                                  from tailscale.com/hostinfo+
-   L ðŸ’£ tailscale.com/util/linuxfw                                   from tailscale.com/net/netns
+   L    tailscale.com/util/linuxfw                                   from tailscale.com/net/netns
         tailscale.com/util/mak                                       from tailscale.com/syncs+
-        tailscale.com/util/multierr                                  from tailscale.com/health+
+        tailscale.com/util/multierr                                  from tailscale.com/health
         tailscale.com/util/set                                       from tailscale.com/health+
         tailscale.com/util/singleflight                              from tailscale.com/net/dnscache
         tailscale.com/util/slicesx                                   from tailscale.com/cmd/derper+
--- a/cmd/tailscale/depaware.txt
+++ b/cmd/tailscale/depaware.txt
@@ -10,7 +10,6 @@ tailscale.com/cmd/tailscale dependencies
    W ðŸ’£ github.com/alexbrainman/sspi                                 from github.com/alexbrainman/sspi/negotiate+
    W    github.com/alexbrainman/sspi/internal/common                 from github.com/alexbrainman/sspi/negotiate
    W ðŸ’£ github.com/alexbrainman/sspi/negotiate                       from tailscale.com/net/tshttpproxy
-   L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw
         github.com/fxamacker/cbor/v2                                 from tailscale.com/tka
         github.com/golang/groupcache/lru                             from tailscale.com/net/dnscache
    L    github.com/google/nftables                                   from tailscale.com/util/linuxfw
@@ -55,20 +54,6 @@ tailscale.com/cmd/tailscale dependencies
         go4.org/netipx                                               from tailscale.com/wgengine/filter
    W ðŸ’£ golang.zx2c4.com/wireguard/windows/tunnel/winipcfg           from tailscale.com/net/interfaces+
         gopkg.in/yaml.v2                                             from sigs.k8s.io/yaml
-   L    gvisor.dev/gvisor/pkg/abi                                    from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/abi/linux                              from tailscale.com/util/linuxfw
-   L    gvisor.dev/gvisor/pkg/bits                                   from gvisor.dev/gvisor/pkg/abi/linux
-   L    gvisor.dev/gvisor/pkg/context                                from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/gohacks                                from gvisor.dev/gvisor/pkg/abi/linux+
-   L ðŸ’£ gvisor.dev/gvisor/pkg/hostarch                               from gvisor.dev/gvisor/pkg/abi/linux+
-   L    gvisor.dev/gvisor/pkg/linewriter                             from gvisor.dev/gvisor/pkg/log
-   L    gvisor.dev/gvisor/pkg/log                                    from gvisor.dev/gvisor/pkg/context
-   L    gvisor.dev/gvisor/pkg/marshal                                from gvisor.dev/gvisor/pkg/abi/linux+
-   L ðŸ’£ gvisor.dev/gvisor/pkg/marshal/primitive                      from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/state                                  from gvisor.dev/gvisor/pkg/abi/linux+
-   L    gvisor.dev/gvisor/pkg/state/wire                             from gvisor.dev/gvisor/pkg/state
-   L ðŸ’£ gvisor.dev/gvisor/pkg/sync                                   from gvisor.dev/gvisor/pkg/linewriter+
-   L    gvisor.dev/gvisor/pkg/waiter                                 from gvisor.dev/gvisor/pkg/context
         k8s.io/client-go/util/homedir                                from tailscale.com/cmd/tailscale/cli
         nhooyr.io/websocket                                          from tailscale.com/derp/derphttp+
         nhooyr.io/websocket/internal/errd                            from nhooyr.io/websocket
@@ -148,7 +133,7 @@ tailscale.com/cmd/tailscale dependencies
         tailscale.com/util/groupmember                               from tailscale.com/cmd/tailscale/cli
         tailscale.com/util/httpm                                     from tailscale.com/client/tailscale
         tailscale.com/util/lineread                                  from tailscale.com/net/interfaces+
-   L ðŸ’£ tailscale.com/util/linuxfw                                   from tailscale.com/net/netns
+   L    tailscale.com/util/linuxfw                                   from tailscale.com/net/netns
         tailscale.com/util/mak                                       from tailscale.com/net/netcheck+
         tailscale.com/util/multierr                                  from tailscale.com/control/controlhttp+
         tailscale.com/util/must                                      from tailscale.com/cmd/tailscale/cli
--- a/cmd/tailscaled/depaware.txt
+++ b/cmd/tailscaled/depaware.txt
@@ -75,7 +75,6 @@ tailscale.com/cmd/tailscaled dependencie
    L    github.com/aws/smithy-go/transport/http                      from github.com/aws/aws-sdk-go-v2/aws/middleware+
    L    github.com/aws/smithy-go/transport/http/internal/io          from github.com/aws/smithy-go/transport/http
    L    github.com/aws/smithy-go/waiter                              from github.com/aws/aws-sdk-go-v2/service/ssm
-   L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw
   LD ðŸ’£ github.com/creack/pty                                        from tailscale.com/ssh/tailssh
    W ðŸ’£ github.com/dblohm7/wingoes                                   from github.com/dblohm7/wingoes/com
    W ðŸ’£ github.com/dblohm7/wingoes/com                               from tailscale.com/cmd/tailscaled
@@ -162,18 +161,13 @@ tailscale.com/cmd/tailscaled dependencie
         go4.org/netipx                                               from tailscale.com/ipn/ipnlocal+
    W ðŸ’£ golang.zx2c4.com/wintun                                      from github.com/tailscale/wireguard-go/tun+
    W ðŸ’£ golang.zx2c4.com/wireguard/windows/tunnel/winipcfg           from tailscale.com/net/dns+
-   L    gvisor.dev/gvisor/pkg/abi                                    from gvisor.dev/gvisor/pkg/abi/linux
-   L ðŸ’£ gvisor.dev/gvisor/pkg/abi/linux                              from tailscale.com/util/linuxfw
         gvisor.dev/gvisor/pkg/atomicbitops                           from gvisor.dev/gvisor/pkg/tcpip+
-        gvisor.dev/gvisor/pkg/bits                                   from gvisor.dev/gvisor/pkg/bufferv2+
+        gvisor.dev/gvisor/pkg/bits                                   from gvisor.dev/gvisor/pkg/bufferv2
      ðŸ’£ gvisor.dev/gvisor/pkg/bufferv2                               from gvisor.dev/gvisor/pkg/tcpip+
-        gvisor.dev/gvisor/pkg/context                                from gvisor.dev/gvisor/pkg/refs+
+        gvisor.dev/gvisor/pkg/context                                from gvisor.dev/gvisor/pkg/refs
      ðŸ’£ gvisor.dev/gvisor/pkg/gohacks                                from gvisor.dev/gvisor/pkg/state/wire+
-   L ðŸ’£ gvisor.dev/gvisor/pkg/hostarch                               from gvisor.dev/gvisor/pkg/abi/linux+
         gvisor.dev/gvisor/pkg/linewriter                             from gvisor.dev/gvisor/pkg/log
         gvisor.dev/gvisor/pkg/log                                    from gvisor.dev/gvisor/pkg/context+
-   L    gvisor.dev/gvisor/pkg/marshal                                from gvisor.dev/gvisor/pkg/abi/linux+
-   L ðŸ’£ gvisor.dev/gvisor/pkg/marshal/primitive                      from gvisor.dev/gvisor/pkg/abi/linux
         gvisor.dev/gvisor/pkg/rand                                   from gvisor.dev/gvisor/pkg/tcpip/network/hash+
         gvisor.dev/gvisor/pkg/refs                                   from gvisor.dev/gvisor/pkg/bufferv2+
      ðŸ’£ gvisor.dev/gvisor/pkg/sleep                                  from gvisor.dev/gvisor/pkg/tcpip/transport/tcp
@@ -333,7 +327,7 @@ tailscale.com/cmd/tailscaled dependencie
      ðŸ’£ tailscale.com/util/hashx                                     from tailscale.com/util/deephash
         tailscale.com/util/httpm                                     from tailscale.com/client/tailscale+
         tailscale.com/util/lineread                                  from tailscale.com/hostinfo+
-   L ðŸ’£ tailscale.com/util/linuxfw                                   from tailscale.com/net/netns+
+   L    tailscale.com/util/linuxfw                                   from tailscale.com/net/netns+
         tailscale.com/util/mak                                       from tailscale.com/control/controlclient+
         tailscale.com/util/multierr                                  from tailscale.com/control/controlclient+
         tailscale.com/util/must                                      from tailscale.com/logpolicy
@@ -482,13 +476,13 @@ tailscale.com/cmd/tailscaled dependencie
         net/textproto                                                from golang.org/x/net/http/httpguts+
         net/url                                                      from crypto/x509+
         os                                                           from crypto/rand+
-        os/exec                                                      from github.com/coreos/go-iptables/iptables+
+        os/exec                                                      from github.com/aws/aws-sdk-go-v2/credentials/processcreds+
         os/signal                                                    from tailscale.com/cmd/tailscaled
         os/user                                                      from github.com/godbus/dbus/v5+
         path                                                         from github.com/godbus/dbus/v5+
         path/filepath                                                from crypto/x509+
         reflect                                                      from crypto/x509+
-        regexp                                                       from github.com/coreos/go-iptables/iptables+
+        regexp                                                       from github.com/aws/aws-sdk-go-v2/internal/endpoints/v2+
         regexp/syntax                                                from regexp
         runtime/debug                                                from github.com/klauspost/compress/zstd+
         runtime/pprof                                                from tailscale.com/log/logheap+
--- a/go.mod
+++ b/go.mod
@@ -14,7 +14,6 @@ require (
 	github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.11.64
 	github.com/aws/aws-sdk-go-v2/service/s3 v1.33.0
 	github.com/aws/aws-sdk-go-v2/service/ssm v1.36.3
-	github.com/coreos/go-iptables v0.6.0
 	github.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf
 	github.com/creack/pty v1.1.18
 	github.com/dave/jennifer v1.6.1
--- a/go.sum
+++ b/go.sum
@@ -216,8 +216,6 @@ github.com/containerd/stargz-snapshotter
 github.com/containerd/stargz-snapshotter/estargz v0.14.3/go.mod h1:KY//uOCIkSuNAHhJogcZtrNHdKrA99/FCCRjE3HD36o=
 github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=
 github.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
-github.com/coreos/go-iptables v0.6.0 h1:is9qnZMPYjLd8LYqmm/qlE+wwEgJIkTYdhV3rfZo4jk=
-github.com/coreos/go-iptables v0.6.0/go.mod h1:Qe8Bv2Xik5FyTXwgIbLAnv2sWSBmvWdFETJConOQ//Q=
 github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
 github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
 github.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf h1:iW4rZ826su+pqaw19uhpSCzhj44qo35pNgKFGqzDKkU=
--- a/util/linuxfw/iptables.go
+++ /dev/null
@@ -1,826 +0,0 @@
-// Copyright (c) Tailscale Inc & AUTHORS
-// SPDX-License-Identifier: BSD-3-Clause
-
-// TODO(#8502): add support for more architectures
-//go:build linux && (arm64 || amd64)
-
-package linuxfw
-
-import (
-	"encoding/hex"
-	"errors"
-	"fmt"
-	"net"
-	"net/netip"
-	"strings"
-	"unsafe"
-
-	"github.com/josharian/native"
-	"golang.org/x/sys/unix"
-	linuxabi "gvisor.dev/gvisor/pkg/abi/linux"
-	"tailscale.com/net/netaddr"
-	"tailscale.com/types/logger"
-)
-
-type sockLen uint32
-
-var (
-	iptablesChainNames = map[int]string{
-		linuxabi.NF_INET_PRE_ROUTING:  "PREROUTING",
-		linuxabi.NF_INET_LOCAL_IN:     "INPUT",
-		linuxabi.NF_INET_FORWARD:      "FORWARD",
-		linuxabi.NF_INET_LOCAL_OUT:    "OUTPUT",
-		linuxabi.NF_INET_POST_ROUTING: "POSTROUTING",
-	}
-	iptablesStandardChains = (func() map[string]bool {
-		ret := make(map[string]bool)
-		for _, v := range iptablesChainNames {
-			ret[v] = true
-		}
-		return ret
-	})()
-)
-
-// DebugNetfilter prints debug information about iptables rules to the
-// provided log function.
-func DebugIptables(logf logger.Logf) error {
-	for _, table := range []string{"filter", "nat", "raw"} {
-		type chainAndEntry struct {
-			chain string
-			entry *entry
-		}
-
-		// Collect all entries first so we can resolve jumps
-		var (
-			lastChain    string
-			ces          []chainAndEntry
-			chainOffsets = make(map[int]string)
-		)
-		err := enumerateIptablesTable(logf, table, func(chain string, entry *entry) error {
-			if chain != lastChain {
-				chainOffsets[entry.Offset] = chain
-				lastChain = chain
-			}
-
-			ces = append(ces, chainAndEntry{
-				chain: lastChain,
-				entry: entry,
-			})
-			return nil
-		})
-		if err != nil {
-			return err
-		}
-
-		lastChain = ""
-		for _, ce := range ces {
-			if ce.chain != lastChain {
-				logf("iptables: table=%s chain=%s", table, ce.chain)
-				lastChain = ce.chain
-			}
-
-			// Fixup jump
-			if std, ok := ce.entry.Target.Data.(standardTarget); ok {
-				if strings.HasPrefix(std.Verdict, "JUMP(") {
-					var off int
-					if _, err := fmt.Sscanf(std.Verdict, "JUMP(%d)", &off); err == nil {
-						if jt, ok := chainOffsets[off]; ok {
-							std.Verdict = "JUMP(" + jt + ")"
-							ce.entry.Target.Data = std
-						}
-					}
-				}
-			}
-
-			logf("iptables:   entry=%+v", ce.entry)
-		}
-	}
-	return nil
-}
-
-// DetectIptables returns the number of iptables rules that are present in the
-// system, ignoring the default "ACCEPT" rule present in the standard iptables
-// chains.
-//
-// It only returns an error when the kernel returns an error (i.e. when a
-// syscall fails); when there are no iptables rules, it is valid for this
-// function to return 0, nil.
-func DetectIptables() (int, error) {
-	dummyLog := func(string, ...any) {}
-
-	var (
-		validRules int
-		firstErr   error
-	)
-	for _, table := range []string{"filter", "nat", "raw"} {
-		err := enumerateIptablesTable(dummyLog, table, func(chain string, entry *entry) error {
-			// If we have any rules other than basic 'ACCEPT' entries in a
-			// standard chain, then we consider this a valid rule.
-			switch {
-			case !iptablesStandardChains[chain]:
-				validRules++
-			case entry.Target.Name != "standard":
-				validRules++
-			case entry.Target.Name == "standard" && entry.Target.Data.(standardTarget).Verdict != "ACCEPT":
-				validRules++
-			}
-			return nil
-		})
-		if err != nil && firstErr == nil {
-			firstErr = err
-		}
-	}
-
-	return validRules, firstErr
-}
-
-func enumerateIptablesTable(logf logger.Logf, table string, cb func(string, *entry) error) error {
-	ln, err := net.Listen("tcp4", ":0")
-	if err != nil {
-		return err
-	}
-	defer ln.Close()
-
-	tcpLn := ln.(*net.TCPListener)
-	conn, err := tcpLn.SyscallConn()
-	if err != nil {
-		return err
-	}
-
-	var tableName linuxabi.TableName
-	copy(tableName[:], []byte(table))
-
-	tbl := linuxabi.IPTGetinfo{
-		Name: tableName,
-	}
-	slt := sockLen(linuxabi.SizeOfIPTGetinfo)
-
-	var ctrlErr error
-	err = conn.Control(func(fd uintptr) {
-		_, _, errno := unix.Syscall6(
-			unix.SYS_GETSOCKOPT,
-			fd,
-			uintptr(unix.SOL_IP),
-			linuxabi.IPT_SO_GET_INFO,
-			uintptr(unsafe.Pointer(&tbl)),
-			uintptr(unsafe.Pointer(&slt)),
-			0,
-		)
-		if errno != 0 {
-			ctrlErr = errno
-			return
-		}
-	})
-	if err != nil {
-		return err
-	}
-	if ctrlErr != nil {
-		return ctrlErr
-	}
-
-	if tbl.Size < 1 {
-		return nil
-	}
-
-	// Allocate enough space to be able to get all iptables information.
-	entsBuf := make([]byte, linuxabi.SizeOfIPTGetEntries+tbl.Size)
-	entsHdr := (*linuxabi.IPTGetEntries)(unsafe.Pointer(&entsBuf[0]))
-	entsHdr.Name = tableName
-	entsHdr.Size = tbl.Size
-
-	slt = sockLen(len(entsBuf))
-
-	err = conn.Control(func(fd uintptr) {
-		_, _, errno := unix.Syscall6(
-			unix.SYS_GETSOCKOPT,
-			fd,
-			uintptr(unix.SOL_IP),
-			linuxabi.IPT_SO_GET_ENTRIES,
-			uintptr(unsafe.Pointer(&entsBuf[0])),
-			uintptr(unsafe.Pointer(&slt)),
-			0,
-		)
-		if errno != 0 {
-			ctrlErr = errno
-			return
-		}
-	})
-	if err != nil {
-		return err
-	}
-	if ctrlErr != nil {
-		return ctrlErr
-	}
-
-	// Skip header
-	entsBuf = entsBuf[linuxabi.SizeOfIPTGetEntries:]
-
-	var (
-		totalOffset  int
-		currentChain string
-	)
-	for len(entsBuf) > 0 {
-		parser := entryParser{
-			buf:             entsBuf,
-			logf:            logf,
-			checkExtraBytes: true,
-		}
-		entry, err := parser.parseEntry(entsBuf)
-		if err != nil {
-			logf("iptables: err=%v", err)
-			break
-		}
-		entry.Offset += totalOffset
-
-		// Don't pass 'ERROR' nodes to our caller
-		if entry.Target.Name == "ERROR" {
-			if parser.offset == len(entsBuf) {
-				// all done
-				break
-			}
-
-			// New user-defined chain
-			currentChain = entry.Target.Data.(errorTarget).ErrorName
-		} else {
-			// Detect if we're at a new chain based on the hook
-			// offsets we fetched earlier.
-			for i, he := range tbl.HookEntry {
-				if int(he) == totalOffset {
-					currentChain = iptablesChainNames[i]
-				}
-			}
-
-			// Now that we have everything, call our callback.
-			if err := cb(currentChain, &entry); err != nil {
-				return err
-			}
-		}
-
-		entsBuf = entsBuf[parser.offset:]
-		totalOffset += parser.offset
-	}
-	return nil
-}
-
-// TODO(andrew): convert to use cstruct
-type entryParser struct {
-	buf    []byte
-	offset int
-
-	logf logger.Logf
-
-	// Set to 'true' to print debug messages about unused bytes returned
-	// from the kernel
-	checkExtraBytes bool
-}
-
-func (p *entryParser) haveLen(ln int) bool {
-	if len(p.buf)-p.offset < ln {
-		return false
-	}
-	return true
-}
-
-func (p *entryParser) assertLen(ln int) error {
-	if !p.haveLen(ln) {
-		return fmt.Errorf("need %d bytes: %w", ln, errBufferTooSmall)
-	}
-	return nil
-}
-
-func (p *entryParser) getBytes(amt int) []byte {
-	ret := p.buf[p.offset : p.offset+amt]
-	p.offset += amt
-	return ret
-}
-
-func (p *entryParser) getByte() byte {
-	ret := p.buf[p.offset]
-	p.offset += 1
-	return ret
-}
-
-func (p *entryParser) get4() (ret [4]byte) {
-	ret[0] = p.buf[p.offset+0]
-	ret[1] = p.buf[p.offset+1]
-	ret[2] = p.buf[p.offset+2]
-	ret[3] = p.buf[p.offset+3]
-	p.offset += 4
-	return
-}
-
-func (p *entryParser) setOffset(off, max int) error {
-	// We can't go back
-	if off < p.offset {
-		return fmt.Errorf("invalid target offset (%d < %d): %w", off, p.offset, errMalformed)
-	}
-
-	// Ensure we don't go beyond our maximum, if given
-	if max >= 0 && off >= max {
-		return fmt.Errorf("invalid target offset (%d >= %d): %w", off, max, errMalformed)
-	}
-
-	// If we aren't already at this offset, move forward
-	if p.offset < off {
-		if p.checkExtraBytes {
-			extraData := p.buf[p.offset:off]
-			diff := off - p.offset
-			p.logf("%d bytes (%d, %d) are unused: %s", diff, p.offset, off, hex.EncodeToString(extraData))
-		}
-
-		p.offset = off
-	}
-	return nil
-}
-
-var (
-	errBufferTooSmall = errors.New("buffer too small")
-	errMalformed      = errors.New("data malformed")
-)
-
-type entry struct {
-	Offset      int
-	IP          iptip
-	NFCache     uint32
-	PacketCount uint64
-	ByteCount   uint64
-	Matches     []match
-	Target      target
-}
-
-func (e entry) String() string {
-	var sb strings.Builder
-	sb.WriteString("{")
-
-	fmt.Fprintf(&sb, "Offset:%d IP:%v PacketCount:%d ByteCount:%d", e.Offset, e.IP, e.PacketCount, e.ByteCount)
-	if len(e.Matches) > 0 {
-		fmt.Fprintf(&sb, " Matches:%v", e.Matches)
-	}
-	fmt.Fprintf(&sb, " Target:%v", e.Target)
-
-	sb.WriteString("}")
-	return sb.String()
-}
-
-func (p *entryParser) parseEntry(b []byte) (entry, error) {
-	startOff := p.offset
-
-	iptip, err := p.parseIPTIP()
-	if err != nil {
-		return entry{}, fmt.Errorf("parsing IPTIP: %w", err)
-	}
-
-	ret := entry{
-		Offset: startOff,
-		IP:     iptip,
-	}
-
-	// Must have space for the rest of the members
-	if err := p.assertLen(28); err != nil {
-		return entry{}, err
-	}
-
-	ret.NFCache = native.Endian.Uint32(p.getBytes(4))
-	targetOffset := int(native.Endian.Uint16(p.getBytes(2)))
-	nextOffset := int(native.Endian.Uint16(p.getBytes(2)))
-	/* unused field: Comeback = */ p.getBytes(4)
-	ret.PacketCount = native.Endian.Uint64(p.getBytes(8))
-	ret.ByteCount = native.Endian.Uint64(p.getBytes(8))
-
-	// Must have at least enough space in our buffer to get to the target;
-	// doing this here means we can avoid bounds checks in parseMatches
-	if err := p.assertLen(targetOffset - p.offset); err != nil {
-		return entry{}, err
-	}
-
-	// Matches are stored between the end of the entry structure and the
-	// start of the 'targets' structure.
-	ret.Matches, err = p.parseMatches(targetOffset)
-	if err != nil {
-		return entry{}, err
-	}
-
-	if targetOffset > 0 {
-		if err := p.setOffset(targetOffset, nextOffset); err != nil {
-			return entry{}, err
-		}
-
-		ret.Target, err = p.parseTarget(nextOffset)
-		if err != nil {
-			return entry{}, fmt.Errorf("parsing target: %w", err)
-		}
-	}
-
-	if err := p.setOffset(nextOffset, -1); err != nil {
-		return entry{}, err
-	}
-
-	return ret, nil
-}
-
-type iptip struct {
-	Src                 netip.Addr
-	Dst                 netip.Addr
-	SrcMask             netip.Addr
-	DstMask             netip.Addr
-	InputInterface      string
-	OutputInterface     string
-	InputInterfaceMask  []byte
-	OutputInterfaceMask []byte
-	Protocol            uint16
-	Flags               uint8
-	InverseFlags        uint8
-}
-
-var protocolNames = map[uint16]string{
-	unix.IPPROTO_ESP:    "esp",
-	unix.IPPROTO_GRE:    "gre",
-	unix.IPPROTO_ICMP:   "icmp",
-	unix.IPPROTO_ICMPV6: "icmpv6",
-	unix.IPPROTO_IGMP:   "igmp",
-	unix.IPPROTO_IP:     "ip",
-	unix.IPPROTO_IPIP:   "ipip",
-	unix.IPPROTO_IPV6:   "ip6",
-	unix.IPPROTO_RAW:    "raw",
-	unix.IPPROTO_TCP:    "tcp",
-	unix.IPPROTO_UDP:    "udp",
-}
-
-func (ip iptip) String() string {
-	var sb strings.Builder
-	sb.WriteString("{")
-
-	formatAddrMask := func(addr, mask netip.Addr) string {
-		if pref, ok := netaddr.FromStdIPNet(&net.IPNet{
-			IP:   addr.AsSlice(),
-			Mask: mask.AsSlice(),
-		}); ok {
-			return fmt.Sprint(pref)
-		}
-		return fmt.Sprintf("%s/%s", addr, mask)
-	}
-
-	fmt.Fprintf(&sb, "Src:%s", formatAddrMask(ip.Src, ip.SrcMask))
-	fmt.Fprintf(&sb, ", Dst:%s", formatAddrMask(ip.Dst, ip.DstMask))
-
-	translateMask := func(mask []byte) string {
-		var ret []byte
-		for _, b := range mask {
-			if b != 0 {
-				ret = append(ret, 'X')
-			} else {
-				ret = append(ret, '.')
-			}
-		}
-		return string(ret)
-	}
-
-	if ip.InputInterface != "" {
-		fmt.Fprintf(&sb, ", InputInterface:%s/%s", ip.InputInterface, translateMask(ip.InputInterfaceMask))
-	}
-	if ip.OutputInterface != "" {
-		fmt.Fprintf(&sb, ", OutputInterface:%s/%s", ip.OutputInterface, translateMask(ip.OutputInterfaceMask))
-	}
-	if nm, ok := protocolNames[ip.Protocol]; ok {
-		fmt.Fprintf(&sb, ", Protocol:%s", nm)
-	} else {
-		fmt.Fprintf(&sb, ", Protocol:%d", ip.Protocol)
-	}
-
-	if ip.Flags != 0 {
-		fmt.Fprintf(&sb, ", Flags:%d", ip.Flags)
-	}
-	if ip.InverseFlags != 0 {
-		fmt.Fprintf(&sb, ", InverseFlags:%d", ip.InverseFlags)
-	}
-
-	sb.WriteString("}")
-	return sb.String()
-}
-
-func (p *entryParser) parseIPTIP() (iptip, error) {
-	if err := p.assertLen(84); err != nil {
-		return iptip{}, err
-	}
-
-	var ret iptip
-
-	ret.Src = netip.AddrFrom4(p.get4())
-	ret.Dst = netip.AddrFrom4(p.get4())
-	ret.SrcMask = netip.AddrFrom4(p.get4())
-	ret.DstMask = netip.AddrFrom4(p.get4())
-
-	const IFNAMSIZ = 16
-	ret.InputInterface = unix.ByteSliceToString(p.getBytes(IFNAMSIZ))
-	ret.OutputInterface = unix.ByteSliceToString(p.getBytes(IFNAMSIZ))
-
-	ret.InputInterfaceMask = p.getBytes(IFNAMSIZ)
-	ret.OutputInterfaceMask = p.getBytes(IFNAMSIZ)
-
-	ret.Protocol = native.Endian.Uint16(p.getBytes(2))
-	ret.Flags = p.getByte()
-	ret.InverseFlags = p.getByte()
-	return ret, nil
-}
-
-type match struct {
-	Name     string
-	Revision int
-	Data     any
-	RawData  []byte
-}
-
-func (m match) String() string {
-	return fmt.Sprintf("{Name:%s, Data:%v}", m.Name, m.Data)
-}
-
-type matchTCP struct {
-	SourcePortRange [2]uint16
-	DestPortRange   [2]uint16
-	Option          byte
-	FlagMask        byte
-	FlagCompare     byte
-	InverseFlags    byte
-}
-
-func (m matchTCP) String() string {
-	var sb strings.Builder
-	sb.WriteString("{")
-
-	fmt.Fprintf(&sb, "SrcPort:%s, DstPort:%s",
-		formatPortRange(m.SourcePortRange),
-		formatPortRange(m.DestPortRange))
-
-	// TODO(andrew): format semantically
-	if m.Option != 0 {
-		fmt.Fprintf(&sb, ", Option:%d", m.Option)
-	}
-	if m.FlagMask != 0 {
-		fmt.Fprintf(&sb, ", FlagMask:%d", m.FlagMask)
-	}
-	if m.FlagCompare != 0 {
-		fmt.Fprintf(&sb, ", FlagCompare:%d", m.FlagCompare)
-	}
-	if m.InverseFlags != 0 {
-		fmt.Fprintf(&sb, ", InverseFlags:%d", m.InverseFlags)
-	}
-
-	sb.WriteString("}")
-	return sb.String()
-}
-
-func (p *entryParser) parseMatches(maxOffset int) ([]match, error) {
-	const XT_EXTENSION_MAXNAMELEN = 29
-	const structSize = 2 + XT_EXTENSION_MAXNAMELEN + 1
-
-	var ret []match
-	for {
-		// If we don't have space for a single match structure, we're done
-		if p.offset+structSize > maxOffset {
-			break
-		}
-
-		var curr match
-
-		matchSize := int(native.Endian.Uint16(p.getBytes(2)))
-		curr.Name = unix.ByteSliceToString(p.getBytes(XT_EXTENSION_MAXNAMELEN))
-		curr.Revision = int(p.getByte())
-
-		// The data size is the total match size minus what we've already consumed.
-		dataLen := matchSize - structSize
-		dataEnd := p.offset + dataLen
-
-		// If we don't have space for the match data, then there's something wrong
-		if dataEnd > maxOffset {
-			return nil, fmt.Errorf("out of space for match (%d > max %d): %w", dataEnd, maxOffset, errMalformed)
-		} else if dataEnd > len(p.buf) {
-			return nil, fmt.Errorf("out of space for match (%d > buf %d): %w", dataEnd, len(p.buf), errMalformed)
-		}
-
-		curr.RawData = p.getBytes(dataLen)
-
-		// TODO(andrew): more here; UDP, etc.
-		switch curr.Name {
-		case "tcp":
-			/*
-			   struct xt_tcp {
-			       __u16 spts[2];  // Source port range.
-			       __u16 dpts[2];  // Destination port range.
-			       __u8 option;    // TCP Option iff non-zero
-			       __u8 flg_mask;  // TCP flags mask byte
-			       __u8 flg_cmp;   // TCP flags compare byte
-			       __u8 invflags;  // Inverse flags
-			   };
-			*/
-			if len(curr.RawData) >= 12 {
-				curr.Data = matchTCP{
-					SourcePortRange: [...]uint16{
-						native.Endian.Uint16(curr.RawData[0:2]),
-						native.Endian.Uint16(curr.RawData[2:4]),
-					},
-					DestPortRange: [...]uint16{
-						native.Endian.Uint16(curr.RawData[4:6]),
-						native.Endian.Uint16(curr.RawData[6:8]),
-					},
-					Option:       curr.RawData[8],
-					FlagMask:     curr.RawData[9],
-					FlagCompare:  curr.RawData[10],
-					InverseFlags: curr.RawData[11],
-				}
-			}
-		}
-
-		ret = append(ret, curr)
-	}
-	return ret, nil
-}
-
-type target struct {
-	Name     string
-	Revision int
-	Data     any
-	RawData  []byte
-}
-
-func (t target) String() string {
-	return fmt.Sprintf("{Name:%s, Data:%v}", t.Name, t.Data)
-}
-
-func (p *entryParser) parseTarget(nextOffset int) (target, error) {
-	const XT_EXTENSION_MAXNAMELEN = 29
-	const structSize = 2 + XT_EXTENSION_MAXNAMELEN + 1
-
-	if err := p.assertLen(structSize); err != nil {
-		return target{}, err
-	}
-
-	var ret target
-
-	targetSize := int(native.Endian.Uint16(p.getBytes(2)))
-	ret.Name = unix.ByteSliceToString(p.getBytes(XT_EXTENSION_MAXNAMELEN))
-	ret.Revision = int(p.getByte())
-
-	if targetSize > structSize {
-		dataLen := targetSize - structSize
-		if err := p.assertLen(dataLen); err != nil {
-			return target{}, err
-		}
-
-		ret.RawData = p.getBytes(dataLen)
-	}
-
-	// Special case; matches what iptables does
-	if ret.Name == "" {
-		ret.Name = "standard"
-	}
-
-	switch ret.Name {
-	case "standard":
-		if len(ret.RawData) >= 4 {
-			verdict := int32(native.Endian.Uint32(ret.RawData))
-
-			var info string
-			switch verdict {
-			case -1:
-				info = "DROP"
-			case -2:
-				info = "ACCEPT"
-			case -4:
-				info = "QUEUE"
-			case -5:
-				info = "RETURN"
-			case int32(nextOffset):
-				info = "FALLTHROUGH"
-			default:
-				info = fmt.Sprintf("JUMP(%d)", verdict)
-			}
-			ret.Data = standardTarget{Verdict: info}
-		}
-
-	case "ERROR":
-		ret.Data = errorTarget{
-			ErrorName: unix.ByteSliceToString(ret.RawData),
-		}
-
-	case "REJECT":
-		if len(ret.RawData) >= 4 {
-			ret.Data = rejectTarget{
-				With: rejectWith(native.Endian.Uint32(ret.RawData)),
-			}
-		}
-
-	case "MARK":
-		if len(ret.RawData) >= 8 {
-			mark := native.Endian.Uint32(ret.RawData[0:4])
-			mask := native.Endian.Uint32(ret.RawData[4:8])
-
-			var mode markMode
-			switch {
-			case mark == 0:
-				mode = markModeAnd
-				mark = ^mask
-
-			case mark == mask:
-				mode = markModeOr
-
-			case mask == 0:
-				mode = markModeXor
-
-			case mask == 0xffffffff:
-				mode = markModeSet
-
-			default:
-				// TODO(andrew): handle xset?
-			}
-
-			ret.Data = markTarget{
-				Mark: mark,
-				Mode: mode,
-			}
-		}
-	}
-
-	return ret, nil
-}
-
-// Various types for things in iptables-land follow.
-
-type standardTarget struct {
-	Verdict string
-}
-
-type errorTarget struct {
-	ErrorName string
-}
-
-type rejectWith int
-
-const (
-	rwIPT_ICMP_NET_UNREACHABLE rejectWith = iota
-	rwIPT_ICMP_HOST_UNREACHABLE
-	rwIPT_ICMP_PROT_UNREACHABLE
-	rwIPT_ICMP_PORT_UNREACHABLE
-	rwIPT_ICMP_ECHOREPLY
-	rwIPT_ICMP_NET_PROHIBITED
-	rwIPT_ICMP_HOST_PROHIBITED
-	rwIPT_TCP_RESET
-	rwIPT_ICMP_ADMIN_PROHIBITED
-)
-
-func (rw rejectWith) String() string {
-	switch rw {
-	case rwIPT_ICMP_NET_UNREACHABLE:
-		return "icmp-net-unreachable"
-	case rwIPT_ICMP_HOST_UNREACHABLE:
-		return "icmp-host-unreachable"
-	case rwIPT_ICMP_PROT_UNREACHABLE:
-		return "icmp-prot-unreachable"
-	case rwIPT_ICMP_PORT_UNREACHABLE:
-		return "icmp-port-unreachable"
-	case rwIPT_ICMP_ECHOREPLY:
-		return "icmp-echo-reply"
-	case rwIPT_ICMP_NET_PROHIBITED:
-		return "icmp-net-prohibited"
-	case rwIPT_ICMP_HOST_PROHIBITED:
-		return "icmp-host-prohibited"
-	case rwIPT_TCP_RESET:
-		return "tcp-reset"
-	case rwIPT_ICMP_ADMIN_PROHIBITED:
-		return "icmp-admin-prohibited"
-	default:
-		return "UNKNOWN"
-	}
-}
-
-type rejectTarget struct {
-	With rejectWith
-}
-
-type markMode byte
-
-const (
-	markModeSet markMode = iota
-	markModeAnd
-	markModeOr
-	markModeXor
-)
-
-func (mm markMode) String() string {
-	switch mm {
-	case markModeSet:
-		return "set"
-	case markModeAnd:
-		return "and"
-	case markModeOr:
-		return "or"
-	case markModeXor:
-		return "xor"
-	default:
-		return "UNKNOWN"
-	}
-}
-
-type markTarget struct {
-	Mode markMode
-	Mark uint32
-}
--- a/util/linuxfw/iptables_runner.go
+++ /dev/null
@@ -1,488 +0,0 @@
-// Copyright (c) Tailscale Inc & AUTHORS
-// SPDX-License-Identifier: BSD-3-Clause
-
-//go:build linux
-
-package linuxfw
-
-import (
-	"fmt"
-	"net/netip"
-	"os/exec"
-	"strings"
-
-	"github.com/coreos/go-iptables/iptables"
-	"tailscale.com/net/tsaddr"
-	"tailscale.com/types/logger"
-	"tailscale.com/util/multierr"
-)
-
-type iptablesInterface interface {
-	// Adding this interface for testing purposes so we can mock out
-	// the iptables library, in reality this is a wrapper to *iptables.IPTables.
-	Insert(table, chain string, pos int, args ...string) error
-	Append(table, chain string, args ...string) error
-	Exists(table, chain string, args ...string) (bool, error)
-	Delete(table, chain string, args ...string) error
-	ClearChain(table, chain string) error
-	NewChain(table, chain string) error
-	DeleteChain(table, chain string) error
-}
-
-type iptablesRunner struct {
-	ipt4 iptablesInterface
-	ipt6 iptablesInterface
-
-	v6Available    bool
-	v6NATAvailable bool
-}
-
-func checkIP6TablesExists() error {
-	// Some distros ship ip6tables separately from iptables.
-	if _, err := exec.LookPath("ip6tables"); err != nil {
-		return fmt.Errorf("path not found: %w", err)
-	}
-	return nil
-}
-
-// NewIPTablesRunner constructs a NetfilterRunner that programs iptables rules.
-// If the underlying iptables library fails to initialize, that error is
-// returned. The runner probes for IPv6 support once at initialization time and
-// if not found, no IPv6 rules will be modified for the lifetime of the runner.
-func NewIPTablesRunner(logf logger.Logf) (*iptablesRunner, error) {
-	ipt4, err := iptables.NewWithProtocol(iptables.ProtocolIPv4)
-	if err != nil {
-		return nil, err
-	}
-
-	supportsV6, supportsV6NAT := false, false
-	v6err := checkIPv6(logf)
-	ip6terr := checkIP6TablesExists()
-	switch {
-	case v6err != nil:
-		logf("disabling tunneled IPv6 due to system IPv6 config: %v", v6err)
-	case ip6terr != nil:
-		logf("disabling tunneled IPv6 due to missing ip6tables: %v", ip6terr)
-	default:
-		supportsV6 = true
-		supportsV6NAT = supportsV6 && checkSupportsV6NAT()
-		logf("v6nat = %v", supportsV6NAT)
-	}
-
-	var ipt6 *iptables.IPTables
-	if supportsV6 {
-		ipt6, err = iptables.NewWithProtocol(iptables.ProtocolIPv6)
-		if err != nil {
-			return nil, err
-		}
-	}
-	return &iptablesRunner{ipt4, ipt6, supportsV6, supportsV6NAT}, nil
-}
-
-// HasIPV6 returns true if the system supports IPv6.
-func (i *iptablesRunner) HasIPV6() bool {
-	return i.v6Available
-}
-
-// HasIPV6NAT returns true if the system supports IPv6 NAT.
-func (i *iptablesRunner) HasIPV6NAT() bool {
-	return i.v6NATAvailable
-}
-
-func isErrChainNotExist(err error) bool {
-	return errCode(err) == 1
-}
-
-// getIPTByAddr returns the iptablesInterface with correct IP family
-// that we will be using for the given address.
-func (i *iptablesRunner) getIPTByAddr(addr netip.Addr) iptablesInterface {
-	nf := i.ipt4
-	if addr.Is6() {
-		nf = i.ipt6
-	}
-	return nf
-}
-
-// AddLoopbackRule adds an iptables rule to permit loopback traffic to
-// a local Tailscale IP.
-func (i *iptablesRunner) AddLoopbackRule(addr netip.Addr) error {
-	if err := i.getIPTByAddr(addr).Insert("filter", "ts-input", 1, "-i", "lo", "-s", addr.String(), "-j", "ACCEPT"); err != nil {
-		return fmt.Errorf("adding loopback allow rule for %q: %w", addr, err)
-	}
-
-	return nil
-}
-
-// tsChain returns the name of the tailscale sub-chain corresponding
-// to the given "parent" chain (e.g. INPUT, FORWARD, ...).
-func tsChain(chain string) string {
-	return "ts-" + strings.ToLower(chain)
-}
-
-// DelLoopbackRule removes the iptables rule permitting loopback
-// traffic to a Tailscale IP.
-func (i *iptablesRunner) DelLoopbackRule(addr netip.Addr) error {
-	if err := i.getIPTByAddr(addr).Delete("filter", "ts-input", "-i", "lo", "-s", addr.String(), "-j", "ACCEPT"); err != nil {
-		return fmt.Errorf("deleting loopback allow rule for %q: %w", addr, err)
-	}
-
-	return nil
-}
-
-// getTables gets the available iptablesInterface in iptables runner.
-func (i *iptablesRunner) getTables() []iptablesInterface {
-	if i.HasIPV6() {
-		return []iptablesInterface{i.ipt4, i.ipt6}
-	}
-	return []iptablesInterface{i.ipt4}
-}
-
-// getNATTables gets the available iptablesInterface in iptables runner.
-// If the system does not support IPv6 NAT, only the IPv4 iptablesInterface
-// is returned.
-func (i *iptablesRunner) getNATTables() []iptablesInterface {
-	if i.HasIPV6NAT() {
-		return i.getTables()
-	}
-	return []iptablesInterface{i.ipt4}
-}
-
-// AddHooks inserts calls to tailscale's netfilter chains in
-// the relevant main netfilter chains. The tailscale chains must
-// already exist. If they do not, an error is returned.
-func (i *iptablesRunner) AddHooks() error {
-	// divert inserts a jump to the tailscale chain in the given table/chain.
-	// If the jump already exists, it is a no-op.
-	divert := func(ipt iptablesInterface, table, chain string) error {
-		tsChain := tsChain(chain)
-
-		args := []string{"-j", tsChain}
-		exists, err := ipt.Exists(table, chain, args...)
-		if err != nil {
-			return fmt.Errorf("checking for %v in %s/%s: %w", args, table, chain, err)
-		}
-		if exists {
-			return nil
-		}
-		if err := ipt.Insert(table, chain, 1, args...); err != nil {
-			return fmt.Errorf("adding %v in %s/%s: %w", args, table, chain, err)
-		}
-		return nil
-	}
-
-	for _, ipt := range i.getTables() {
-		if err := divert(ipt, "filter", "INPUT"); err != nil {
-			return err
-		}
-		if err := divert(ipt, "filter", "FORWARD"); err != nil {
-			return err
-		}
-	}
-
-	for _, ipt := range i.getNATTables() {
-		if err := divert(ipt, "nat", "POSTROUTING"); err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-// AddChains creates custom Tailscale chains in netfilter via iptables
-// if the ts-chain doesn't already exist.
-func (i *iptablesRunner) AddChains() error {
-	// create creates a chain in the given table if it doesn't already exist.
-	// If the chain already exists, it is a no-op.
-	create := func(ipt iptablesInterface, table, chain string) error {
-		err := ipt.ClearChain(table, chain)
-		if isErrChainNotExist(err) {
-			// nonexistent chain. let's create it!
-			return ipt.NewChain(table, chain)
-		}
-		if err != nil {
-			return fmt.Errorf("setting up %s/%s: %w", table, chain, err)
-		}
-		return nil
-	}
-
-	for _, ipt := range i.getTables() {
-		if err := create(ipt, "filter", "ts-input"); err != nil {
-			return err
-		}
-		if err := create(ipt, "filter", "ts-forward"); err != nil {
-			return err
-		}
-	}
-
-	for _, ipt := range i.getNATTables() {
-		if err := create(ipt, "nat", "ts-postrouting"); err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// AddBase adds some basic processing rules to be supplemented by
-// later calls to other helpers.
-func (i *iptablesRunner) AddBase(tunname string) error {
-	if err := i.addBase4(tunname); err != nil {
-		return err
-	}
-	if i.HasIPV6() {
-		if err := i.addBase6(tunname); err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-// addBase4 adds some basic IPv6 processing rules to be
-// supplemented by later calls to other helpers.
-func (i *iptablesRunner) addBase4(tunname string) error {
-	// Only allow CGNAT range traffic to come from tailscale0. There
-	// is an exception carved out for ranges used by ChromeOS, for
-	// which we fall out of the Tailscale chain.
-	//
-	// Note, this will definitely break nodes that end up using the
-	// CGNAT range for other purposes :(.
-	args := []string{"!", "-i", tunname, "-s", tsaddr.ChromeOSVMRange().String(), "-j", "RETURN"}
-	if err := i.ipt4.Append("filter", "ts-input", args...); err != nil {
-		return fmt.Errorf("adding %v in v4/filter/ts-input: %w", args, err)
-	}
-	args = []string{"!", "-i", tunname, "-s", tsaddr.CGNATRange().String(), "-j", "DROP"}
-	if err := i.ipt4.Append("filter", "ts-input", args...); err != nil {
-		return fmt.Errorf("adding %v in v4/filter/ts-input: %w", args, err)
-	}
-
-	// Forward all traffic from the Tailscale interface, and drop
-	// traffic to the tailscale interface by default. We use packet
-	// marks here so both filter/FORWARD and nat/POSTROUTING can match
-	// on these packets of interest.
-	//
-	// In particular, we only want to apply SNAT rules in
-	// nat/POSTROUTING to packets that originated from the Tailscale
-	// interface, but we can't match on the inbound interface in
-	// POSTROUTING. So instead, we match on the inbound interface in
-	// filter/FORWARD, and set a packet mark that nat/POSTROUTING can
-	// use to effectively run that same test again.
-	args = []string{"-i", tunname, "-j", "MARK", "--set-mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask}
-	if err := i.ipt4.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v4/filter/ts-forward: %w", args, err)
-	}
-	args = []string{"-m", "mark", "--mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask, "-j", "ACCEPT"}
-	if err := i.ipt4.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v4/filter/ts-forward: %w", args, err)
-	}
-	args = []string{"-o", tunname, "-s", tsaddr.CGNATRange().String(), "-j", "DROP"}
-	if err := i.ipt4.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v4/filter/ts-forward: %w", args, err)
-	}
-	args = []string{"-o", tunname, "-j", "ACCEPT"}
-	if err := i.ipt4.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v4/filter/ts-forward: %w", args, err)
-	}
-
-	return nil
-}
-
-// addBase6 adds some basic IPv4 processing rules to be
-// supplemented by later calls to other helpers.
-func (i *iptablesRunner) addBase6(tunname string) error {
-	// TODO: only allow traffic from Tailscale's ULA range to come
-	// from tailscale0.
-
-	args := []string{"-i", tunname, "-j", "MARK", "--set-mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask}
-	if err := i.ipt6.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v6/filter/ts-forward: %w", args, err)
-	}
-	args = []string{"-m", "mark", "--mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask, "-j", "ACCEPT"}
-	if err := i.ipt6.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v6/filter/ts-forward: %w", args, err)
-	}
-	// TODO: drop forwarded traffic to tailscale0 from tailscale's ULA
-	// (see corresponding IPv4 CGNAT rule).
-	args = []string{"-o", tunname, "-j", "ACCEPT"}
-	if err := i.ipt6.Append("filter", "ts-forward", args...); err != nil {
-		return fmt.Errorf("adding %v in v6/filter/ts-forward: %w", args, err)
-	}
-
-	return nil
-}
-
-// DelChains removes the custom Tailscale chains from netfilter via iptables.
-func (i *iptablesRunner) DelChains() error {
-	for _, ipt := range i.getTables() {
-		if err := delChain(ipt, "filter", "ts-input"); err != nil {
-			return err
-		}
-		if err := delChain(ipt, "filter", "ts-forward"); err != nil {
-			return err
-		}
-	}
-
-	for _, ipt := range i.getNATTables() {
-		if err := delChain(ipt, "nat", "ts-postrouting"); err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// DelBase empties but does not remove custom Tailscale chains from
-// netfilter via iptables.
-func (i *iptablesRunner) DelBase() error {
-	del := func(ipt iptablesInterface, table, chain string) error {
-		if err := ipt.ClearChain(table, chain); err != nil {
-			if isErrChainNotExist(err) {
-				// nonexistent chain. That's fine, since it's
-				// the desired state anyway.
-				return nil
-			}
-			return fmt.Errorf("flushing %s/%s: %w", table, chain, err)
-		}
-		return nil
-	}
-
-	for _, ipt := range i.getTables() {
-		if err := del(ipt, "filter", "ts-input"); err != nil {
-			return err
-		}
-		if err := del(ipt, "filter", "ts-forward"); err != nil {
-			return err
-		}
-	}
-	for _, ipt := range i.getNATTables() {
-		if err := del(ipt, "nat", "ts-postrouting"); err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// DelHooks deletes the calls to tailscale's netfilter chains
-// in the relevant main netfilter chains.
-func (i *iptablesRunner) DelHooks(logf logger.Logf) error {
-	for _, ipt := range i.getTables() {
-		if err := delTSHook(ipt, "filter", "INPUT", logf); err != nil {
-			return err
-		}
-		if err := delTSHook(ipt, "filter", "FORWARD", logf); err != nil {
-			return err
-		}
-	}
-	for _, ipt := range i.getNATTables() {
-		if err := delTSHook(ipt, "nat", "POSTROUTING", logf); err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// AddSNATRule adds a netfilter rule to SNAT traffic destined for
-// local subnets.
-func (i *iptablesRunner) AddSNATRule() error {
-	args := []string{"-m", "mark", "--mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask, "-j", "MASQUERADE"}
-	for _, ipt := range i.getNATTables() {
-		if err := ipt.Append("nat", "ts-postrouting", args...); err != nil {
-			return fmt.Errorf("adding %v in nat/ts-postrouting: %w", args, err)
-		}
-	}
-	return nil
-}
-
-// DelSNATRule removes the netfilter rule to SNAT traffic destined for
-// local subnets. An error is returned if the rule does not exist.
-func (i *iptablesRunner) DelSNATRule() error {
-	args := []string{"-m", "mark", "--mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask, "-j", "MASQUERADE"}
-	for _, ipt := range i.getNATTables() {
-		if err := ipt.Delete("nat", "ts-postrouting", args...); err != nil {
-			return fmt.Errorf("deleting %v in nat/ts-postrouting: %w", args, err)
-		}
-	}
-	return nil
-}
-
-// IPTablesCleanup removes all Tailscale added iptables rules.
-// Any errors that occur are logged to the provided logf.
-func IPTablesCleanup(logf logger.Logf) {
-	err := clearRules(iptables.ProtocolIPv4, logf)
-	if err != nil {
-		logf("linuxfw: clear iptables: %v", err)
-	}
-
-	err = clearRules(iptables.ProtocolIPv6, logf)
-	if err != nil {
-		logf("linuxfw: clear ip6tables: %v", err)
-	}
-}
-
-// delTSHook deletes hook in a chain that jumps to a ts-chain. If the hook does not
-// exist, it's a no-op since the desired state is already achieved but we log the
-// error because error code from the iptables module resists unwrapping.
-func delTSHook(ipt iptablesInterface, table, chain string, logf logger.Logf) error {
-	tsChain := tsChain(chain)
-	args := []string{"-j", tsChain}
-	if err := ipt.Delete(table, chain, args...); err != nil {
-		// TODO(apenwarr): check for errCode(1) here.
-		// Unfortunately the error code from the iptables
-		// module resists unwrapping, unlike with other
-		// calls. So we have to assume if Delete fails,
-		// it's because there is no such rule.
-		logf("deleting %v in %s/%s: %v", args, table, chain, err)
-		return nil
-	}
-	return nil
-}
-
-// delChain flushs and deletes a chain. If the chain does not exist, it's a no-op
-// since the desired state is already achieved. otherwise, it returns an error.
-func delChain(ipt iptablesInterface, table, chain string) error {
-	if err := ipt.ClearChain(table, chain); err != nil {
-		if isErrChainNotExist(err) {
-			// nonexistent chain. nothing to do.
-			return nil
-		}
-		return fmt.Errorf("flushing %s/%s: %w", table, chain, err)
-	}
-	if err := ipt.DeleteChain(table, chain); err != nil {
-		return fmt.Errorf("deleting %s/%s: %w", table, chain, err)
-	}
-	return nil
-}
-
-// clearRules clears all the iptables rules created by Tailscale
-// for the given protocol. If error occurs, it's logged but not returned.
-func clearRules(proto iptables.Protocol, logf logger.Logf) error {
-	ipt, err := iptables.NewWithProtocol(proto)
-	if err != nil {
-		return err
-	}
-
-	var errs []error
-
-	if err := delTSHook(ipt, "filter", "INPUT", logf); err != nil {
-		errs = append(errs, err)
-	}
-	if err := delTSHook(ipt, "filter", "FORWARD", logf); err != nil {
-		errs = append(errs, err)
-	}
-	if err := delTSHook(ipt, "nat", "POSTROUTING", logf); err != nil {
-		errs = append(errs, err)
-	}
-
-	if err := delChain(ipt, "filter", "ts-input"); err != nil {
-		errs = append(errs, err)
-	}
-	if err := delChain(ipt, "filter", "ts-forward"); err != nil {
-		errs = append(errs, err)
-	}
-
-	if err := delChain(ipt, "nat", "ts-postrouting"); err != nil {
-		errs = append(errs, err)
-	}
-
-	return multierr.New(errs...)
-}
--- a/util/linuxfw/iptables_runner_test.go
+++ /dev/null
@@ -1,420 +0,0 @@
-// Copyright (c) Tailscale Inc & AUTHORS
-// SPDX-License-Identifier: BSD-3-Clause
-
-//go:build linux
-
-package linuxfw
-
-import (
-	"errors"
-	"net/netip"
-	"strings"
-	"testing"
-
-	"tailscale.com/net/tsaddr"
-)
-
-var errExec = errors.New("execution failed")
-
-type fakeIPTables struct {
-	t *testing.T
-	n map[string][]string
-}
-
-type fakeRule struct {
-	table, chain string
-	args         []string
-}
-
-func newIPTables(t *testing.T) *fakeIPTables {
-	return &fakeIPTables{
-		t: t,
-		n: map[string][]string{
-			"filter/INPUT":    nil,
-			"filter/OUTPUT":   nil,
-			"filter/FORWARD":  nil,
-			"nat/PREROUTING":  nil,
-			"nat/OUTPUT":      nil,
-			"nat/POSTROUTING": nil,
-		},
-	}
-}
-
-func (n *fakeIPTables) Insert(table, chain string, pos int, args ...string) error {
-	k := table + "/" + chain
-	if rules, ok := n.n[k]; ok {
-		if pos > len(rules)+1 {
-			n.t.Errorf("bad position %d in %s", pos, k)
-			return errExec
-		}
-		rules = append(rules, "")
-		copy(rules[pos:], rules[pos-1:])
-		rules[pos-1] = strings.Join(args, " ")
-		n.n[k] = rules
-	} else {
-		n.t.Errorf("unknown table/chain %s", k)
-		return errExec
-	}
-	return nil
-}
-
-func (n *fakeIPTables) Append(table, chain string, args ...string) error {
-	k := table + "/" + chain
-	return n.Insert(table, chain, len(n.n[k])+1, args...)
-}
-
-func (n *fakeIPTables) Exists(table, chain string, args ...string) (bool, error) {
-	k := table + "/" + chain
-	if rules, ok := n.n[k]; ok {
-		for _, rule := range rules {
-			if rule == strings.Join(args, " ") {
-				return true, nil
-			}
-		}
-		return false, nil
-	} else {
-		n.t.Logf("unknown table/chain %s", k)
-		return false, errExec
-	}
-}
-
-func hasChain(n *fakeIPTables, table, chain string) bool {
-	k := table + "/" + chain
-	if _, ok := n.n[k]; ok {
-		return true
-	} else {
-		return false
-	}
-}
-
-func (n *fakeIPTables) Delete(table, chain string, args ...string) error {
-	k := table + "/" + chain
-	if rules, ok := n.n[k]; ok {
-		for i, rule := range rules {
-			if rule == strings.Join(args, " ") {
-				rules = append(rules[:i], rules[i+1:]...)
-				n.n[k] = rules
-				return nil
-			}
-		}
-		n.t.Errorf("delete of unknown rule %q from %s", strings.Join(args, " "), k)
-		return errExec
-	} else {
-		n.t.Errorf("unknown table/chain %s", k)
-		return errExec
-	}
-}
-
-func (n *fakeIPTables) ClearChain(table, chain string) error {
-	k := table + "/" + chain
-	if _, ok := n.n[k]; ok {
-		n.n[k] = nil
-		return nil
-	} else {
-		n.t.Logf("note: ClearChain: unknown table/chain %s", k)
-		return errors.New("exitcode:1")
-	}
-}
-
-func (n *fakeIPTables) NewChain(table, chain string) error {
-	k := table + "/" + chain
-	if _, ok := n.n[k]; ok {
-		n.t.Errorf("table/chain %s already exists", k)
-		return errExec
-	}
-	n.n[k] = nil
-	return nil
-}
-
-func (n *fakeIPTables) DeleteChain(table, chain string) error {
-	k := table + "/" + chain
-	if rules, ok := n.n[k]; ok {
-		if len(rules) != 0 {
-			n.t.Errorf("%s is not empty", k)
-			return errExec
-		}
-		delete(n.n, k)
-		return nil
-	} else {
-		n.t.Errorf("%s does not exist", k)
-		return errExec
-	}
-}
-
-func newFakeIPTablesRunner(t *testing.T) *iptablesRunner {
-	ipt4 := newIPTables(t)
-	ipt6 := newIPTables(t)
-
-	iptr := &iptablesRunner{ipt4, ipt6, true, true}
-	return iptr
-}
-
-func TestAddAndDeleteChains(t *testing.T) {
-	iptr := newFakeIPTablesRunner(t)
-	err := iptr.AddChains()
-	if err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the chains were created.
-	tsChains := []struct{ table, chain string }{ // table/chain
-		{"filter", "ts-input"},
-		{"filter", "ts-forward"},
-		{"nat", "ts-postrouting"},
-	}
-
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		for _, tc := range tsChains {
-			// Exists returns error if the chain doesn't exist.
-			if _, err := proto.Exists(tc.table, tc.chain); err != nil {
-				t.Errorf("chain %s/%s doesn't exist", tc.table, tc.chain)
-			}
-		}
-	}
-
-	err = iptr.DelChains()
-	if err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the chains were deleted.
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		for _, tc := range tsChains {
-			if _, err = proto.Exists(tc.table, tc.chain); err == nil {
-				t.Errorf("chain %s/%s still exists", tc.table, tc.chain)
-			}
-		}
-	}
-
-}
-
-func TestAddAndDeleteHooks(t *testing.T) {
-	iptr := newFakeIPTablesRunner(t)
-	// don't need to test what happens if the chains don't exist, because
-	// this is handled by fake iptables, in realife iptables would return error.
-	if err := iptr.AddChains(); err != nil {
-		t.Fatal(err)
-	}
-	defer iptr.DelChains()
-
-	if err := iptr.AddHooks(); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rules were created.
-	tsRules := []fakeRule{ // table/chain/rule
-		{"filter", "INPUT", []string{"-j", "ts-input"}},
-		{"filter", "FORWARD", []string{"-j", "ts-forward"}},
-		{"nat", "POSTROUTING", []string{"-j", "ts-postrouting"}},
-	}
-
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		for _, tr := range tsRules {
-			if exists, err := proto.Exists(tr.table, tr.chain, tr.args...); err != nil {
-				t.Fatal(err)
-			} else if !exists {
-				t.Errorf("rule %s/%s/%s doesn't exist", tr.table, tr.chain, strings.Join(tr.args, " "))
-			}
-			// check if the rule is at front of the chain
-			if proto.(*fakeIPTables).n[tr.table+"/"+tr.chain][0] != strings.Join(tr.args, " ") {
-				t.Errorf("v4 rule %s/%s/%s is not at the top", tr.table, tr.chain, strings.Join(tr.args, " "))
-			}
-		}
-	}
-
-	if err := iptr.DelHooks(t.Logf); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rules were deleted.
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		for _, tr := range tsRules {
-			if exists, err := proto.Exists(tr.table, tr.chain, tr.args...); err != nil {
-				t.Fatal(err)
-			} else if exists {
-				t.Errorf("rule %s/%s/%s still exists", tr.table, tr.chain, strings.Join(tr.args, " "))
-			}
-		}
-	}
-
-	if err := iptr.AddHooks(); err != nil {
-		t.Fatal(err)
-	}
-}
-
-func TestAddAndDeleteBase(t *testing.T) {
-	iptr := newFakeIPTablesRunner(t)
-	tunname := "tun0"
-	if err := iptr.AddChains(); err != nil {
-		t.Fatal(err)
-	}
-
-	if err := iptr.AddBase(tunname); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rules were created.
-	tsRulesV4 := []fakeRule{ // table/chain/rule
-		{"filter", "ts-input", []string{"!", "-i", tunname, "-s", tsaddr.ChromeOSVMRange().String(), "-j", "RETURN"}},
-		{"filter", "ts-input", []string{"!", "-i", tunname, "-s", tsaddr.CGNATRange().String(), "-j", "DROP"}},
-		{"filter", "ts-forward", []string{"-o", tunname, "-s", tsaddr.CGNATRange().String(), "-j", "DROP"}},
-	}
-
-	tsRulesCommon := []fakeRule{ // table/chain/rule
-		{"filter", "ts-forward", []string{"-i", tunname, "-j", "MARK", "--set-mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask}},
-		{"filter", "ts-forward", []string{"-m", "mark", "--mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask, "-j", "ACCEPT"}},
-		{"filter", "ts-forward", []string{"-o", tunname, "-j", "ACCEPT"}},
-	}
-
-	// check that the rules were created for ipt4
-	for _, tr := range append(tsRulesV4, tsRulesCommon...) {
-		if exists, err := iptr.ipt4.Exists(tr.table, tr.chain, tr.args...); err != nil {
-			t.Fatal(err)
-		} else if !exists {
-			t.Errorf("rule %s/%s/%s doesn't exist", tr.table, tr.chain, strings.Join(tr.args, " "))
-		}
-	}
-
-	// check that the rules were created for ipt6
-	for _, tr := range tsRulesCommon {
-		if exists, err := iptr.ipt6.Exists(tr.table, tr.chain, tr.args...); err != nil {
-			t.Fatal(err)
-		} else if !exists {
-			t.Errorf("rule %s/%s/%s doesn't exist", tr.table, tr.chain, strings.Join(tr.args, " "))
-		}
-	}
-
-	if err := iptr.DelBase(); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rules were deleted.
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		for _, tr := range append(tsRulesV4, tsRulesCommon...) {
-			if exists, err := proto.Exists(tr.table, tr.chain, tr.args...); err != nil {
-				t.Fatal(err)
-			} else if exists {
-				t.Errorf("rule %s/%s/%s still exists", tr.table, tr.chain, strings.Join(tr.args, " "))
-			}
-		}
-	}
-
-	if err := iptr.DelChains(); err != nil {
-		t.Fatal(err)
-	}
-}
-
-func TestAddAndDelLoopbackRule(t *testing.T) {
-	iptr := newFakeIPTablesRunner(t)
-	// We don't need to test for malformed addresses, AddLoopbackRule
-	// takes in a netip.Addr, which is already valid.
-	fakeAddrV4 := netip.MustParseAddr("192.168.0.2")
-	fakeAddrV6 := netip.MustParseAddr("2001:db8::2")
-
-	if err := iptr.AddChains(); err != nil {
-		t.Fatal(err)
-	}
-	if err := iptr.AddLoopbackRule(fakeAddrV4); err != nil {
-		t.Fatal(err)
-	}
-	if err := iptr.AddLoopbackRule(fakeAddrV6); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rules were created.
-	tsRulesV4 := fakeRule{ // table/chain/rule
-		"filter", "ts-input", []string{"-i", "lo", "-s", fakeAddrV4.String(), "-j", "ACCEPT"}}
-
-	tsRulesV6 := fakeRule{ // table/chain/rule
-		"filter", "ts-input", []string{"-i", "lo", "-s", fakeAddrV6.String(), "-j", "ACCEPT"}}
-
-	// check that the rules were created for ipt4 and ipt6
-	if exist, err := iptr.ipt4.Exists(tsRulesV4.table, tsRulesV4.chain, tsRulesV4.args...); err != nil {
-		t.Fatal(err)
-	} else if !exist {
-		t.Errorf("rule %s/%s/%s doesn't exist", tsRulesV4.table, tsRulesV4.chain, strings.Join(tsRulesV4.args, " "))
-	}
-	if exist, err := iptr.ipt6.Exists(tsRulesV6.table, tsRulesV6.chain, tsRulesV6.args...); err != nil {
-		t.Fatal(err)
-	} else if !exist {
-		t.Errorf("rule %s/%s/%s doesn't exist", tsRulesV6.table, tsRulesV6.chain, strings.Join(tsRulesV6.args, " "))
-	}
-
-	// check that the rule is at the top
-	chain := "filter/ts-input"
-	if iptr.ipt4.(*fakeIPTables).n[chain][0] != strings.Join(tsRulesV4.args, " ") {
-		t.Errorf("v4 rule %s/%s/%s is not at the top", tsRulesV4.table, tsRulesV4.chain, strings.Join(tsRulesV4.args, " "))
-	}
-	if iptr.ipt6.(*fakeIPTables).n[chain][0] != strings.Join(tsRulesV6.args, " ") {
-		t.Errorf("v6 rule %s/%s/%s is not at the top", tsRulesV6.table, tsRulesV6.chain, strings.Join(tsRulesV6.args, " "))
-	}
-
-	// delete the rules
-	if err := iptr.DelLoopbackRule(fakeAddrV4); err != nil {
-		t.Fatal(err)
-	}
-	if err := iptr.DelLoopbackRule(fakeAddrV6); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rules were deleted.
-	if exist, err := iptr.ipt4.Exists(tsRulesV4.table, tsRulesV4.chain, tsRulesV4.args...); err != nil {
-		t.Fatal(err)
-	} else if exist {
-		t.Errorf("rule %s/%s/%s still exists", tsRulesV4.table, tsRulesV4.chain, strings.Join(tsRulesV4.args, " "))
-	}
-
-	if exist, err := iptr.ipt6.Exists(tsRulesV6.table, tsRulesV6.chain, tsRulesV6.args...); err != nil {
-		t.Fatal(err)
-	} else if exist {
-		t.Errorf("rule %s/%s/%s still exists", tsRulesV6.table, tsRulesV6.chain, strings.Join(tsRulesV6.args, " "))
-	}
-
-	if err := iptr.DelChains(); err != nil {
-		t.Fatal(err)
-	}
-}
-
-func TestAddAndDelSNATRule(t *testing.T) {
-	iptr := newFakeIPTablesRunner(t)
-
-	if err := iptr.AddChains(); err != nil {
-		t.Fatal(err)
-	}
-
-	rule := fakeRule{ // table/chain/rule
-		"nat", "ts-postrouting", []string{"-m", "mark", "--mark", TailscaleSubnetRouteMark + "/" + TailscaleFwmarkMask, "-j", "MASQUERADE"},
-	}
-
-	// Add SNAT rule
-	if err := iptr.AddSNATRule(); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rule was created for ipt4 and ipt6
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		if exist, err := proto.Exists(rule.table, rule.chain, rule.args...); err != nil {
-			t.Fatal(err)
-		} else if !exist {
-			t.Errorf("rule %s/%s/%s doesn't exist", rule.table, rule.chain, strings.Join(rule.args, " "))
-		}
-	}
-
-	// Delete SNAT rule
-	if err := iptr.DelSNATRule(); err != nil {
-		t.Fatal(err)
-	}
-
-	// Check that the rule was deleted for ipt4 and ipt6
-	for _, proto := range []iptablesInterface{iptr.ipt4, iptr.ipt6} {
-		if exist, err := proto.Exists(rule.table, rule.chain, rule.args...); err != nil {
-			t.Fatal(err)
-		} else if exist {
-			t.Errorf("rule %s/%s/%s still exists", rule.table, rule.chain, strings.Join(rule.args, " "))
-		}
-	}
-
-	if err := iptr.DelChains(); err != nil {
-		t.Fatal(err)
-	}
-}
--- a/wgengine/router/router_linux.go
+++ b/wgengine/router/router_linux.go
@@ -21,6 +21,7 @@ import (
 	"go4.org/netipx"
 	"golang.org/x/sys/unix"
 	"golang.org/x/time/rate"
+
 	"tailscale.com/envknob"
 	"tailscale.com/net/netmon"
 	"tailscale.com/types/logger"
@@ -37,7 +38,7 @@ const (
 )
 
 // netfilterRunner abstracts helpers to run netfilter commands. It is
-// implemented by linuxfw.IPTablesRunner and linuxfw.NfTablesRunner.
+// implemented by linuxfw.NfTablesRunner.
 type netfilterRunner interface {
 	AddLoopbackRule(addr netip.Addr) error
 	DelLoopbackRule(addr netip.Addr) error
@@ -54,23 +55,14 @@ type netfilterRunner interface {
 	HasIPV6NAT() bool
 }
 
-// newNetfilterRunner creates a netfilterRunner using either nftables or iptables.
-// As nftables is still experimental, iptables will be used unless TS_DEBUG_USE_NETLINK_NFTABLES is set.
+// newNetfilterRunner creates a netfilterRunner using nftables.
 func newNetfilterRunner(logf logger.Logf) (netfilterRunner, error) {
 	var nfr netfilterRunner
 	var err error
-	if envknob.Bool("TS_DEBUG_USE_NETLINK_NFTABLES") {
-		logf("router: using nftables")
-		nfr, err = linuxfw.NewNfTablesRunner(logf)
-		if err != nil {
-			return nil, err
-		}
-	} else {
-		logf("router: using iptables")
-		nfr, err = linuxfw.NewIPTablesRunner(logf)
-		if err != nil {
-			return nil, err
-		}
+	logf("router: using nftables")
+	nfr, err = linuxfw.NewNfTablesRunner(logf)
+	if err != nil {
+		return nil, err
 	}
 	return nfr, nil
 }
@@ -1054,7 +1046,6 @@ func (r *linuxRouter) justAddIPRules() e
 	}
 	var errAcc error
 	for _, family := range r.addrFamilies() {
-
 		for _, ru := range ipRules {
 			// Note: r is a value type here; safe to mutate it.
 			ru.Family = family.netlinkInt()
@@ -1294,7 +1285,6 @@ func normalizeCIDR(cidr netip.Prefix) st
 // netfilter runner is used, the cleanup function for the other one doesn't do anything.
 func cleanup(logf logger.Logf, interfaceName string) {
 	if interfaceName != "userspace-networking" {
-		linuxfw.IPTablesCleanup(logf)
 		linuxfw.NfTablesCleanUp(logf)
 	}
 }
